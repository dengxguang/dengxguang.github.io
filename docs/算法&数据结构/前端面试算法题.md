# 前端面试常见算法题汇总

本文档旨在系统性地梳理前端面试中常见的算法题，并提供核心的解题思路和代码实现。

---

## 一、 数组和字符串

### 1. 数组扁平化（Array Flatten）

**问题描述：**
请实现一个函数，将一个嵌套的多维数组“扁平化”处理，变成一个一维数组。例如，`[1, [2, [3, 4], 5], 6]` 转换后应为 `[1, 2, 3, 4, 5, 6]`。

**解题思路：**
这道题主要考察对数组操作和递归的理解。常见的解法有：
1.  **递归法：** 遍历数组，如果元素是数组，则递归调用自身，否则将其 `concat` 到结果数组中。这是最直观的思路。
2.  **`flat()` API：** ES2019 引入了 `Array.prototype.flat(depth)` 方法，可以直接使用。`depth` 参数指定要提取的嵌套层数，默认为1。可以传入 `Infinity` 来处理任意深度的嵌套。
3.  **迭代法（栈）：** 使用栈来模拟递归过程，避免递归深度过大的问题。将数组元素逆序入栈，然后依次出栈处理。如果是数组，则将其元素再次逆序入栈。

**代码实现 (ES6):**
```javascript
function flatten(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    if (Array.isArray(arr[i])) {
      result = result.concat(flatten(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}

// 或者使用 flat()
const arr = [1, [2, [3, 4], 5], 6];
console.log(arr.flat(Infinity)); // [1, 2, 3, 4, 5, 6]
```

### 2. 最长无重复子串

**问题描述：**
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**解题思路：**
这个问题可以使用“滑动窗口”的思想来解决。
1.  维护一个窗口（可以用哈希表/Set来记录窗口内的字符）。
2.  使用两个指针，`left` 和 `right`，`right` 指针不断向右移动。
3.  当遇到重复字符时，移动 `left` 指针，缩小窗口，直到窗口内没有重复字符。
4.  在此过程中，不断更新最长子串的长度。

**代码实现:**
```javascript
function lengthOfLongestSubstring(s) {
  const set = new Set();
  let left = 0;
  let maxLength = 0;

  for (let right = 0; right < s.length; right++) {
    while (set.has(s[right])) {
      set.delete(s[left]);
      left++;
    }
    set.add(s[right]);
    maxLength = Math.max(maxLength, right - left + 1);
  }
  return maxLength;
}

console.log(lengthOfLongestSubstring("abcabcbb")); // 3
console.log(lengthOfLongestSubstring("bbbbb")); // 1
```

### 3. 版本号排序

**问题描述:**
给定一个包含版本号的数组，请实现一个排序函数。例如，`['2.1.0', '1.2.11', '1.3.0', '1.2.3']` 排序后应为 `['1.2.3', '1.2.11', '1.3.0', '2.1.0']`。

**解题思路:**
版本号排序不能简单地按字符串大小进行比较。需要将每个版本号按 `.` 分割成数字数组，然后逐位进行比较。
1.  使用 `Array.prototype.sort()` 方法，并传入一个自定义的比较函数。
2.  在比较函数中，将两个版本号字符串 `a` 和 `b` 分别用 `split('.')` 转换成数组。
3.  遍历两个数组，逐个将对应位置的字符串转换为数字进行比较。
4.  如果当前位的数字不相等，则可以直接返回它们的差值。
5.  如果遍历完较短的数组后所有位都相等，则较长的版本号更大。

**代码实现:**
```javascript
function sortVersions(versions) {
  return versions.sort((a, b) => {
    const aParts = a.split('.').map(Number);
    const bParts = b.split('.').map(Number);
    const maxLength = Math.max(aParts.length, bParts.length);

    for (let i = 0; i < maxLength; i++) {
      const aVal = aParts[i] || 0;
      const bVal = bParts[i] || 0;
      if (aVal !== bVal) {
        return aVal - bVal;
      }
    }
    return 0;
  });
}

const versions = ['2.1.0', '1.2.11', '1.3.0', '1.2.3'];
console.log(sortVersions(versions));
// 输出: ["1.2.3", "1.2.11", "1.3.0", "2.1.0"]
```

---

## 二、 树与递归

### 1. 二叉树的深度优先遍历（DFS）

**问题描述:**
给定一个二叉树，请分别用前序、中序、后序遍历该树。这三种遍历方式是深度优先遍历（DFS）的典型应用。

**解题思路:**
递归是实现DFS最简洁的方式。
*   **前序遍历 (Pre-order):** 根 -> 左 -> 右
*   **中序遍历 (In-order):** 左 -> 根 -> 右
*   **后序遍历 (Post-order):** 左 -> 右 -> 根

对于迭代法，可以借助栈来实现：
*   **前序:** 根节点入栈，出栈时访问，然后将其右、左子节点依次入栈。
*   **中序:** 一路将左子节点入栈，到底后出栈访问，然后处理右子树。
*   **后序:** 类似前序，但访问顺序是“左右根”，可以转换成“根右左”的逆序。

**代码实现 (递归):**
```javascript
function TreeNode(val, left, right) {
  this.val = (val===undefined ? 0 : val)
  this.left = (left===undefined ? null : left)
  this.right = (right===undefined ? null : right)
}

// 前序遍历
function preorderTraversal(root) {
  const res = [];
  const dfs = (node) => {
    if (!node) return;
    res.push(node.val);
    dfs(node.left);
    dfs(node.right);
  };
  dfs(root);
  return res;
}

// 中序遍历
function inorderTraversal(root) {
  const res = [];
  const dfs = (node) => {
    if (!node) return;
    dfs(node.left);
    res.push(node.val);
    dfs(node.right);
  };
  dfs(root);
  return res;
}
```

### 2. 将有序数组转换为二叉搜索树

**问题描述:**
将一个按照升序排列的有序数组，转换为一棵高度平衡的二叉搜索树。

**解题思路:**
为了保证高度平衡，我们需要选择数组的 **中间元素** 作为根节点。
1.  找到数组的中点 `mid`。
2.  将 `mid` 对应的元素作为根节点。
3.  递归地处理 `mid` 左边的子数组，构建左子树。
4.  递归地处理 `mid` 右边的子数组，构建右子树。

这个过程天然地保证了树的平衡性。

**代码实现:**
```javascript
function sortedArrayToBST(nums) {
  if (!nums.length) {
    return null;
  }

  const mid = Math.floor(nums.length / 2);
  const root = new TreeNode(nums[mid]);

  root.left = sortedArrayToBST(nums.slice(0, mid));
  root.right = sortedArrayToBST(nums.slice(mid + 1));

  return root;
}
```

### 3. 二叉树的层序遍历（BFS）

**问题描述:**
给定一个二叉树，返回其节点值的层序遍历。 （即逐层地，从左到右访问所有节点）。

**解题思路:**
层序遍历通常使用广度优先搜索（BFS）实现，借助一个队列来完成。
1.  创建一个队列 `queue`，并将根节点 `root` 入队。
2.  当队列不为空时，循环执行以下操作：
    *   记录当前队列的长度 `levelSize`，这个长度就是当前层的节点数。
    *   创建一个 `currentLevel` 数组，用于存放当前层的所有节点值。
    *   循环 `levelSize` 次，从队列中出队一个节点。
    *   将出队节点的值存入 `currentLevel` 数组。
    *   如果该节点有左子节点，则将其左子节点入队。
    *   如果该节点有右子节点，则将其右子节点入队。
3.  将 `currentLevel` 存入最终的结果数组。

**代码实现:**
```javascript
function levelOrder(root) {
  if (!root) {
    return [];
  }

  const result = [];
  const queue = [root];

  while (queue.length > 0) {
    const levelSize = queue.length;
    const currentLevel = [];

    for (let i = 0; i < levelSize; i++) {
      const node = queue.shift();
      currentLevel.push(node.val);

      if (node.left) {
        queue.push(node.left);
      }
      if (node.right) {
        queue.push(node.right);
      }
    }
    result.push(currentLevel);
  }

  return result;
}
```

---

## 三、 异步与并发控制

### 1. 手写实现 Promise.all

**问题描述:**
请实现一个 `Promise.all` 函数，它接受一个 Promise 数组作为输入，当所有 Promise 都变为 resolved 状态后，返回一个包含所有 Promise 结果的数组。如果其中任何一个 Promise 被 rejected，则整个 `Promise.all` 就会立即被 rejected。

**解题思路:**
1.  返回一个新的 Promise。
2.  创建一个计数器 `count` 和一个结果数组 `results`。
3.  遍历输入的 Promise 数组。
4.  对于每个 Promise，使用 `.then` 来处理其 resolved 状态。当它成功时，将结果存入 `results` 的对应位置，并将 `count` 加一。
5.  检查 `count` 是否等于 Promise 数组的长度，如果相等，说明所有 Promise 都已成功，此时 resolve 新的 Promise 并返回 `results`。
6.  如果任何一个 Promise 被 reject，则立即 reject 新的 Promise。

**代码实现:**
```javascript
function promiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Arguments must be an array'));
    }
    let resolvedCounter = 0;
    const promiseNum = promises.length;
    const resolvedValues = new Array(promiseNum);

    for (let i = 0; i < promiseNum; i++) {
      Promise.resolve(promises[i]).then(
        value => {
          resolvedCounter++;
          resolvedValues[i] = value;
          if (resolvedCounter === promiseNum) {
            return resolve(resolvedValues);
          }
        },
        error => {
          return reject(error);
        }
      );
    }
  });
}
```

### 2. 实现一个带并发限制的异步调度器

**问题描述:**
实现一个`Scheduler`类，使得可以添加异步任务，并控制并发任务的数量。

**解题思路:**
1.  `Scheduler` 类需要一个队列 `queue` 来存储待执行的任务，一个 `maxCount` 来限制并发数，以及一个 `runningCount` 来记录当前正在运行的任务数。
2.  `add` 方法负责接收异步任务（一个返回Promise的函数），并将其存入队列。
3.  需要一个 `run` 方法来执行任务。当 `runningCount < maxCount` 并且队列不为空时，从队列中取出一个任务执行。
4.  任务执行前，`runningCount` 加一。
5.  任务执行完毕后（无论成功还是失败），`runningCount` 减一，并**递归调用 `run` 方法**，尝试执行下一个任务。这确保了任务的连续执行。

**代码实现:**
```javascript
class Scheduler {
  constructor(maxCount) {
    this.queue = [];
    this.maxCount = maxCount;
    this.runningCount = 0;
  }

  add(promiseCreator) {
    this.queue.push(promiseCreator);
    this.run();
  }

  run() {
    if (this.runningCount < this.maxCount && this.queue.length > 0) {
      const promiseCreator = this.queue.shift();
      this.runningCount++;

      promiseCreator().then(() => {
        this.runningCount--;
        this.run();
      });
    }
  }
}

// 使用示例
const timeout = time => new Promise(resolve => setTimeout(resolve, time));
const scheduler = new Scheduler(2);
const addTask = (time, order) => {
  scheduler.add(() => timeout(time).then(() => console.log(order)));
};

addTask(1000, '1');
addTask(500, '2');
addTask(300, '3');
addTask(400, '4');
// 输出: 2 3 1 4
```

### 3. 实现 Promise.retry

**问题描述:**
实现一个 `retry` 函数，接收一个异步任务函数 `asyncFn` 和一个重试次数 `retries` 作为参数。`retry` 函数会尝试执行 `asyncFn`，如果它 `reject`，则会进行重试，直到达到最大重试次数。如果成功，则 `resolve` 结果；如果所有尝试都失败，则 `reject` 最后一次的错误。

**解题思路:**
可以使用 `async/await` 结合 `try...catch` 来实现，也可以用 `.catch` 链。
1.  创建一个内部函数（例如 `attempt`），用于执行异步任务。
2.  在 `attempt` 中，调用 `asyncFn`。
3.  如果 `asyncFn` 成功 `resolve`，则直接 `resolve` 整个 `retry` 函数返回的 Promise。
4.  如果 `asyncFn` 失败 `reject`，则在 `catch` 块中检查剩余的重试次数。
    *   如果还有重试次数，则将 `retries` 减一，并递归调用 `attempt`。
    *   如果没有重试次数了，则 `reject` 整个 Promise，并传递最后一次的错误。

**代码实现:**
```javascript
function retry(asyncFn, retries) {
  return new Promise((resolve, reject) => {
    const attempt = (currentTry) => {
      asyncFn()
        .then(resolve)
        .catch(error => {
          if (currentTry <= retries) {
            console.log(`Attempt ${currentTry} failed. Retrying...`);
            attempt(currentTry + 1);
          } else {
            reject(error);
          }
        });
    };
    attempt(1);
  });
}

// 使用示例
let i = 0;
const fetchWithRetry = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      i++;
      if (i < 3) {
        reject(new Error(`Failed on attempt ${i}`));
      } else {
        resolve(`Succeeded on attempt ${i}`);
      }
    }, 500);
  });
};

retry(fetchWithRetry, 3)
  .then(result => console.log(result)) // Succeeded on attempt 3
  .catch(error => console.error(error));
```

---

## 四、 经典问题手写实现

### 1. 函数防抖（Debounce）

**问题描述:**
实现一个 `debounce` 函数，该函数接收一个函数和延迟时间作为参数，返回一个新函数。当这个新函数被连续调用时，只有在最后一次调用结束后、经过指定的延迟时间后，原始函数才会被执行。

**解题思路:**
1.  利用闭包来保存一个定时器 `timer`。
2.  每次调用新函数时，先清除上一次的定时器。
3.  然后，设置一个新的定时器，在延迟时间后执行原始函数。
4.  需要考虑 `this` 指向和事件对象 `event` 的传递。可以使用 `apply` 或 `call` 来确保函数在正确的上下文中执行。

**代码实现:**
```javascript
function debounce(fn, delay) {
  let timer = null;

  return function(...args) {
    const context = this;
    
    if (timer) {
      clearTimeout(timer);
    }

    timer = setTimeout(() => {
      fn.apply(context, args);
    }, delay);
  };
}

// 使用示例
const sayHello = () => console.log('Hello');
const debouncedSayHello = debounce(sayHello, 1000);
// 快速连续调用，但 "Hello"只会在最后一次调用1秒后打印一次
debouncedSayHello();
debouncedSayHello();
debouncedSayHello();
```

### 2. 深拷贝（Deep Clone）

**问题描述:**
实现一个 `deepClone` 函数，可以完整地复制一个JavaScript对象，包括其嵌套的对象和数组，同时要处理循环引用的问题。

**解题思路:**
1.  基础思路是递归。遍历对象的属性，如果属性值是对象或数组，则递归调用 `deepClone`。
2.  **处理循环引用:** 这是深拷贝的关键难点。可以使用一个 `Map` 或 `WeakMap` 来存储已经拷贝过的对象。在拷贝前，检查 `Map` 中是否已有当前对象。如果有，则直接返回 `Map` 中的拷贝结果，避免无限循环。
3.  需要考虑多种数据类型，如 `null`, `Date`, `RegExp` 等。
4.  可以使用 `Object.prototype.toString.call(obj)` 来获取准确的数据类型。

**代码实现 (处理循环引用):**
```javascript
function deepClone(obj, hash = new WeakMap()) {
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理 Date 和 RegExp
  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj);

  // 检查循环引用
  if (hash.has(obj)) {
    return hash.get(obj);
  }

  const cloneObj = new obj.constructor();
  hash.set(obj, cloneObj);

  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], hash);
    }
  }
  
  return cloneObj;
}
```

### 3. 函数节流（Throttle）

**问题描述:**
实现一个 `throttle` 函数，该函数接收一个函数和时间间隔作为参数。当这个新函数被连续调用时，它会确保原始函数在每个时间间隔内最多只执行一次。

**解题思路:**
节流有两种常见的实现方式：时间戳版和定时器版。
1.  **时间戳版:**
    *   使用一个 `previous` 变量记录上一次执行的时间。
    *   每次触发事件时，获取当前时间 `now`。
    *   如果 `now - previous` 大于或等于设定的时间间隔，则执行函数，并更新 `previous` 为 `now`。
    *   这种方式的特点是第一次事件会立即执行，最后一次事件可能不会执行。
2.  **定时器版:**
    *   使用一个 `timer` 变量。
    *   当事件触发时，如果 `timer` 不存在，则设置一个定时器，在指定延迟后执行函数，并将 `timer` 设为 `null`。
    *   如果 `timer` 存在，则不做任何事。
    *   这种方式的特点是第一次事件不会立即执行，但能保证最后一次事件被执行。

**代码实现 (定时器版):**
```javascript
function throttle(fn, delay) {
  let timer = null;

  return function(...args) {
    const context = this;
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(context, args);
        timer = null;
      }, delay);
    }
  };
}

// 使用示例
const onScroll = (event) => console.log('Scroll event:', event);
const throttledScroll = throttle(onScroll, 1000);
window.addEventListener('scroll', throttledScroll);
// 在1秒内无论滚动多少次，'Scroll event'最多只打印一次
```

---

## 五、 数据结构设计

### 1. LRU 缓存机制 (Least Recently Used)

**问题描述:**
设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作：`get` 和 `put`。
*   `get(key)`: 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。
*   `put(key, value)`: 如果键不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前，删除最近最少使用的数据值。

**解题思路:**
LRU 的核心思想是“如果一个数据在最近被访问，那么它在将来被访问的概率也很高”。为了实现 O(1) 时间复杂度的 `get` 和 `put` 操作，需要两种数据结构结合：
1.  **哈希表 (Map):** 用于快速查找（O(1)），存储 `key` 到 `(key, value)` 节点（或直接是value）的映射。
2.  **双向链表 (Doubly Linked List):** 用于记录访问的先后次序。链表头部表示最新访问的，尾部表示最久未访问的。

操作逻辑：
*   `get`: 通过哈希表找到节点，将其移动到链表头部，并返回其值。
*   `put`:
    *   如果 key 已存在，更新其值，并将其移动到链表头部。
    *   如果 key 不存在：
        *   创建一个新节点，存入哈希表，并插入到链表头部。
        *   检查缓存是否已满。如果已满，则删除链表尾部节点，并从哈希表中也删除对应的 key。

**代码实现 (ES6 Map):**
> 注意：以下是利用 ES6 `Map` 自身有序的特性实现的简化版，在一些面试中可能会被追问手动实现双向链表的版本。

```javascript
class LRUCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.map = new Map();
  }

  get(key) {
    if (this.map.has(key)) {
      const value = this.map.get(key);
      // 先删除，再重新设置，保证其最新
      this.map.delete(key);
      this.map.set(key, value);
      return value;
    }
    return -1;
  }

  put(key, value) {
    if (this.map.has(key)) {
      this.map.delete(key);
    }
    
    this.map.set(key, value);

    if (this.map.size > this.capacity) {
      // map.keys().next().value 获取 Map 中最老的元素
      this.map.delete(this.map.keys().next().value);
    }
  }
}

### 2. 实现发布-订阅模式

**问题描述:**
实现一个 `EventEmitter` 类，它包含 `on`、`off` 和 `emit` 方法，用于实现发布-订阅模式。
*   `on(eventName, callback)`: 订阅一个事件。
*   `off(eventName, callback)`: 取消订阅一个事件。
*   `emit(eventName, ...args)`: 发布一个事件，并传递参数给所有的订阅者。

**解题思路:**
1.  在类中使用一个对象（如 `Map` 或普通对象） `events` 来存储所有事件和其对应的回调函数数组。`key` 是事件名，`value` 是一个回调函数数组。
2.  `on` 方法:
    *   根据 `eventName` 查找 `events` 中是否有对应的数组。
    *   如果没有，则创建一个新数组。
    *   将 `callback` 添加到该数组中。
3.  `emit` 方法:
    *   根据 `eventName` 找到对应的回调函数数组。
    *   遍历数组，并依次执行所有回调函数，同时将 `...args` 传递给它们。
4.  `off` 方法:
    *   找到 `eventName` 对应的回调函数数组。
    *   从数组中找到并移除指定的 `callback`。如果 `callback` 未提供，则可以清空该事件的所有订阅。

**代码实现:**
```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
  }

  emit(eventName, ...args) {
    const eventCallbacks = this.events[eventName];
    if (eventCallbacks) {
      eventCallbacks.forEach(callback => {
        callback(...args);
      });
    }
  }

  off(eventName, callback) {
    const eventCallbacks = this.events[eventName];
    if (eventCallbacks) {
      this.events[eventName] = eventCallbacks.filter(cb => cb !== callback);
    }
  }
}

// 使用示例
const emitter = new EventEmitter();
const callback1 = (name) => console.log(`Hello, ${name}!`);
const callback2 = (name) => console.log(`Goodbye, ${name}!`);

emitter.on('greet', callback1);
emitter.on('greet', callback2);

emitter.emit('greet', 'Kilo'); // Hello, Kilo! Goodbye, Kilo!

emitter.off('greet', callback1);
emitter.emit('greet', 'Code'); // Goodbye, Code!
```