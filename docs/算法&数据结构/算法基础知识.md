## 算法核心概念

### 算法解题完整流程

1. 画图梳理阶梯思路
2. 代码实现
3. 功能测试
4. 单元测试
5. 性能分析

### 算法复杂度
> 算法复杂度：指的是程序执行时需要的cpu计算量和内存空间（和代码量是否简洁无关）；复杂度是一个**数量级，**不是具体数字。例如：O(n^2), O(nlogn), O(n), O(logn), O(1).....

1. 时间复杂度：程序执行时需要cpu的计算量
2. 空间复杂度：程序执行时需要内存空间
3. 前端：重时间，轻空间
4. 经典题目：把一个数组旋转K步 比如[1,2,3,4,5,6,7]旋转3步得到[5,6,7,1,2,3,4] 
- 思路分析
> 思路1：把末尾的元素挨个pop，然后unshift到数组前面；注意数组是一个有序结构，unshift、spiice、shift这些操作特别耗性能，原因是因为每个元素都需要移动位置。
> 思路2：把数组拆分，最后concat拼接到一起

- 代码实现
  
```typescript
// 描述: 数组翻转k步 (pop、unshift方式实现)
export const rotate1 = (arr: number[], k: number): number[] => {
  const length = arr.length;
  if (!k || length === 0) return arr;
  const step = Math.abs(k % length);
  // 总体 O(n^2)
  for (let i = 0; i < step; i++) { // O(n)
    const n = arr.pop();
    if (n != null) {
      arr.unshift(n); // O(n)
    }
  }
  return arr;
}
// 描述: 数组翻转k步 (concat实现方式)
export const rotate2 = (arr: number[], k: number): number[] => {
  const length = arr.length;
  if (!k || length === 0) return arr;
  const step = Math.abs(k % length);
  const arr1 = arr.slice(-step)
  const arr2 = arr.slice(0, length - step)
  const arr3 = arr1.concat(arr2)
  return arr3
}
// 性能分析
// rotate2: 56.898193359375 ms
const arr2 = [];
for(let i =0; i< 10*10000; i++) {
  arr2.push(i)
}
console.time('rotate2')
console.log(rotate2(arr2, 90000))
console.timeEnd('rotate2')
// rotate1: 1418.778076171875 ms
const arr1 = [];
for(let i =0; i< 10*10000; i++) {
  arr1.push(i)
}
console.time('rotate1')
console.log(rotate1(arr1, 90000))
console.timeEnd('rotate1')
```

- 功能测试
```typescript
//功能测试
const arr1 = [1, 2, 3, 4, 5, 6, 7];
console.log(rotate2(arr1, 2)) // [6,7,1,2,3,4,5]
```

- 单元测试

```typescript
import { describe, expect, it } from 'vitest';
import { rotate1 } from './rotate-array'
describe('数组翻转 pop/unshift方式', () => {
  it('正常情况', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 4;
    expect(rotate1(arr, k)).toEqual([4, 5, 6, 7, 1, 2, 3])
  })
  it('数组为空', () => {
    const arr: any[] = [];
    const k = 3;
    expect(rotate1(arr, k)).toEqual([])
  })
  it('k 为负数', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = -3;
    expect(rotate1(arr, k)).toEqual([5, 6, 7, 1, 2, 3, 4])
  })
  it('k是0', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 0;
    expect(rotate1(arr, k)).toEqual([1, 2, 3, 4, 5, 6, 7])
  })
  it('k不是数字', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 'abc';
    expect(rotate1(arr, k)).toEqual([1, 2, 3, 4, 5, 6, 7])
  })
})
```

```typescript
import { describe, expect, it } from 'vitest';
import { rotate2 } from './rotate-array'
describe('数组翻转 concat方式', () => {
  it('正常情况', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 4;
    expect(rotate2(arr, k)).toEqual([4, 5, 6, 7, 1, 2, 3])
  })
  it('数组为空', () => {
    const arr: any[] = [];
    const k = 3;
    expect(rotate2(arr, k)).toEqual([])
  })
  it('k 为负数', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = -3;
    expect(rotate2(arr, k)).toEqual([5, 6, 7, 1, 2, 3, 4])
  })
  it('k是0', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 0;
    expect(rotate2(arr, k)).toEqual([1, 2, 3, 4, 5, 6, 7])
  })
  it('k不是数字', () => {
    const arr = [1, 2, 3, 4, 5, 6, 7];
    const k = 'abc';
    expect(rotate2(arr, k)).toEqual([1, 2, 3, 4, 5, 6, 7])
  })
})
```

- 性能分析（复杂度分析）
> 思路一（pop+unshift）：时间复杂度O(n^2)，空间复杂度O(1)
> 思路二（concat）:时间复杂度O(1)，空间复杂度O(n)

### 算法思维

#### 贪心
> 贪心 (Greedy): 像一个“目光短浅”但行动果断的人。做决策时，他从不考虑长远后果，只选择眼前看起来最好的选项。

##### 核心思想
在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的局部最优解。

##### 适用场景
贪心算法并非对所有问题都能得到整体最优解，其使用的前提是：
1. 贪心选择性质（Greedy Choice Property）:全局最优解可以通过一系列局部最优的选择（贪心选择）来达到。这是贪心算法和动态规划的主要区别。
2. 最优子结构（Optimal Substructure）:一个问题的最优解包含其子问题的最优解。

##### 解题步骤
1. **建立数学模型**：将问题分解为多个子问题。
2. **确定贪心策略**：找出问题的最优解，这个解应当是当前看起来最好的选择。
3. **汇总策略**：将所有子问题的局部最优解合并，得到原问题的解。

##### 经典例子：找零钱
假设有面额为 25分、10分、5分、1分的硬币，现在要找给顾客 41 分钱，如何使得硬币数量最少？
- **贪心策略**：每次都选择面额最大的硬币。
- **过程**：
  1. 取出一个 25 分，还剩 16 分。
  2. 取出一个 10 分，还剩 6 分。
  3. 取出一个 5 分，还剩 1 分。
  4. 取出一个 1 分，还剩 0 分。
- **结果**：25 + 10 + 5 + 1 = 41，共4枚硬币，是该场景的最优解
- **注意**：贪心策略并不总是有效。如果硬币面额为 11分、5分、1分，要找 15 分，贪心策略会是 11 + 1 + 1 + 1 + 1 (5枚)，而最优解是 5 + 5 + 5 (3枚)。

##### 代码实现
```ts
/**
 * 贪心算法 - 找零钱问题
 * 给定不同面额的硬币和一个总金额，计算可以凑成总金额所需的最少硬币个数
 * 注意：这里假设硬币面额是标准的（如 25, 10, 5, 1），贪心策略才能得到最优解
 */
function coinChangeGreedy(coins: number[], amount: number): number[] {
  // 按面额从大到小排序
  coins.sort((a, b) => b - a);
  
  const result: number[] = [];
  let remaining = amount;
  
  for (const coin of coins) {
      // 贪心策略：尽可能多地使用当前面额的硬币
      while (remaining >= coin) {
          result.push(coin);
          remaining -= coin;
      }
  }
  
  // 如果还有剩余，说明无法完全找零
  if (remaining > 0) {
      throw new Error('无法完全找零');
  }
  
  return result;
}

// 使用示例
const coins = [25, 10, 5, 1];
const amount = 41;
const changeCoins = coinChangeGreedy(coins, amount);
console.log(`找零 ${amount} 分需要的硬币：`, changeCoins);
console.log(`硬币数量：${changeCoins.length}`);
// 输出：找零 41 分需要的硬币： [25, 10, 5, 1]
// 输出：硬币数量：4

```
  
#### 二分
> 二分 (Binary Search): 像一个高效的图书管理员。找书时，他不会一页一页翻，而是直接翻到书的中间，判断目标在哪一半，然后对那一半重复此过程，每次都将查找范围缩小一半。

##### 核心思想
二分思想的核心是“分治”，它通过不断地将问题的规模缩小一半来快速定位目标。它不仅仅用于查找，任何具有单调性的问题，都可以考虑使用二分法来求解。

##### 适用条件
  1. **有序性**：数据序列必须是有序的（升序或者降序）。
  2. **单调性**：问题答案的分布具有单调性。例如在一个函数中，如果x点的某个条件成立，那么大于x的点该条件都成立。
   
##### 解题步骤（查找为例）
  1. **确定边界**：设定左边边界（left）和右边边界（right），初始时，left = 0, right = n - 1。
  2. **循环折半**：当 left <= right 时，循环执行以下操作：
     1. 计算中间位置 mid = left + (right - left) / 2 (这样写可以防止溢出)。
     2. 比较 mid 位置的元素和目标值 target。
     3. 如果 array[mid] == target，则找到目标。
     4. 如果 array[mid] < target，说明目标在右半区，更新 left = mid + 1。
     5. 果 array[mid] > target，说明目标在左半区，更新 right = mid - 1。

##### 经典例子：在有序数组中查找元素
在一个升序数组 [2, 5, 7, 8, 11, 12] 中查找 11。
- **过程**：
  1. left=0, right=5, mid=2。array[2] 是 7，小于 11。范围缩小到 [8, 11, 12]，更新 left=3。
  2. left=3, right=5, mid=4。array[4] 是 11，等于目标。查找成功。

##### 代码实现

```typescript
/**
 * 二分查找 - 在有序数组中查找目标值
 * 时间复杂度：O(log n)
 * 空间复杂度：O(1)
 */
function binarySearch(arr: number[], target: number): number {
  let left = 0;
  let right = arr.length - 1;
  
  while (left <= right) {
      // 防止溢出的中点计算方式
      const mid = left + Math.floor((right - left) / 2);
      
      console.log(`查找范围: [${left}, ${right}], 中点: ${mid}, 中点值: ${arr[mid]}`);
      
      if (arr[mid] === target) {
          return mid; // 找到目标，返回索引
      } else if (arr[mid] < target) {
          left = mid + 1; // 目标在右半部分
      } else {
          right = mid - 1; // 目标在左半部分
      }
  }
  
  return -1; // 未找到目标
}

/**
 * 二分查找的递归实现
 */
function binarySearchRecursive(
    arr: number[], 
    target: number, 
    left: number = 0, 
    right: number = arr.length - 1
): number {
    if (left > right) {
        return -1; // 未找到
    }
    
    const mid = left + Math.floor((right - left) / 2);
    
    if (arr[mid] === target) {
        return mid;
    } else if (arr[mid] < target) {
        return binarySearchRecursive(arr, target, mid + 1, right);
    } else {
        return binarySearchRecursive(arr, target, left, mid - 1);
    }
}

// 使用示例
const sortedArray = [2, 5, 7, 8, 11, 12];
const target = 11;
console.log('\n=== 二分查找示例 ===');
const index = binarySearch(sortedArray, target);
console.log(`在数组 [${sortedArray.join(', ')}] 中查找 ${target}`);
console.log(`找到位置：${index}`);

```

#### 动态规划
> 动态规划 (Dynamic Programming): 像一个“有备无患”的智者。他会将一个大问题拆解成很多小问题，然后从小问题开始解决，并把每个小问题的答案都记录在案（备忘录）。当解决更大的问题需要用到某个小问题的答案时，他会直接查阅备忘录，而不是重新计算。

##### 核心思想
将一个复杂的问题分解为若干个更小的、相互关联的子问题，通过求解并存储子问题的解，来避免重复计算，最终自底向上地构建出原问题的解。其本质是空间换时间。

##### 适用条件
1. **重叠子问题（Overlapping Subproblems）**：在问题的递归解法中，某些子问题被反复计算多次。
2. **最优子结构**：和贪心一样，一个问题的最优解包含其子问题的最优解。
3. **无后效性**：子问题的解一旦确定，就不会再改变。
4. **边界**：必须有一个明确的终止条件。

##### 解题步骤
1. **定义状态（State）**：这是最关键也是最难的一步。通常用一个数组dp[i]或者dp[i][j]来表示问题在规模为i（或者i,j）时的解。例如，dp[i]可以表示‘爬到第i级台阶的方法数’。
2. **找出状态转移方程（State Transition Equation）**：这是DP的核心。建立当前状态和其前一个或多个状态之间的关系。例如，dp[i] = dp[i-1] + dp[i-2] (爬楼梯问题)。
3. **确定初始状态（Base Case）**：确定最小子问题的解，作为递推的起点。例如，dp[0]=1, dp[1]=1。
4. **确定计算顺序**：通常是自底向上（从小问题到大问题）进行计算。
5. **返回值**：返回 dp 数组的最终结果。

**DP与贪心的核心区别：** 贪心只关心当前的局部最优，而DP会考虑所有子问题的最优解，并从中选择一个来构成当前状态的最优解，它会“回看”过去所有相关的状态。

##### 经典例子：
斐波那契数列F(n) = F(n-1) + F(n-2)，其中 F(0)=0, F(1)=1。
- **状态定义**：dp[i] 表示第i个斐波那契数的值。
- **状态转移方程**：dp[i] = dp[i-1] + dp[i-2]。
- **初始状态**：dp[0] = 0, dp[1] = 1。
- **过程**
  1. dp[2] = dp[1] + dp[0] = 1
  2. dp[3] = dp[2] + dp[1] = 2
  3. ...依次计算知道dp[n]。

这种方式避免了普通递归中大量的重复计算（如计算 F(5) 时会多次重复计算 F(3)）。

##### 代码实现

```typescript
/**
 * 动态规划 - 斐波那契数列
 * F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1
 */

// 方法1：基础动态规划（使用数组存储所有中间结果）
function fibonacciDP(n: number): number {
  if (n <= 1) return n;
  
  // dp[i] 表示第 i 个斐波那契数
  const dp: number[] = new Array(n + 1);
  dp[0] = 0;
  dp[1] = 1;
  
  console.log(`F(0) = ${dp[0]}, F(1) = ${dp[1]}`);
  
  for (let i = 2; i <= n; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
      console.log(`F(${i}) = F(${i-1}) + F(${i-2}) = ${dp[i-1]} + ${dp[i-2]} = ${dp[i]}`);
  }
  
  return dp[n];
}

// 方法2：空间优化的动态规划（只保存前两个状态）
function fibonacciDPOptimized(n: number): number {
  if (n <= 1) return n;
  
  let prev2 = 0; // F(i-2)
  let prev1 = 1; // F(i-1)
  let current = 0;
  
  for (let i = 2; i <= n; i++) {
      current = prev1 + prev2;
      prev2 = prev1;
      prev1 = current;
  }
  
  return current;
}

// 方法3：记忆化递归（自顶向下的动态规划）
function fibonacciMemo(n: number, memo: Map<number, number> = new Map()): number {
  if (n <= 1) return n;
  
  // 如果已经计算过，直接返回缓存结果
  if (memo.has(n)) {
      console.log(`从缓存中获取 F(${n}) = ${memo.get(n)}`);
      return memo.get(n)!;
  }
  
  // 递归计算并缓存结果
  const result = fibonacciMemo(n - 1, memo) + fibonacciMemo(n - 2, memo);
  memo.set(n, result);
  console.log(`计算并缓存 F(${n}) = ${result}`);
  
  return result;
}

// 使用示例
console.log('\n=== 动态规划 - 斐波那契数列 ===');
const n = 8;

console.log('\n--- 基础动态规划 ---');
const result1 = fibonacciDP(n);
console.log(`F(${n}) = ${result1}`);

console.log('\n--- 空间优化动态规划 ---');
const result2 = fibonacciDPOptimized(n);
console.log(`F(${n}) = ${result2}`);

console.log('\n--- 记忆化递归 ---');
const result3 = fibonacciMemo(n);
console.log(`F(${n}) = ${result3}`);


```

#### 栈（stack）
**一、栈的基础知识**

1. 特点：先进后出
2. API:  push（入栈/压栈）、pop（出栈）、length（长度）
3. 相关：队列、堆
4. 栈 vs 数组
> 栈：逻辑结构，理论模型。不管如何实现，不收任何语言的限制；
> 数组：物理结构，有对应的API方法，真实的功能实现，受限于编程语言

5. 数组实现一个栈
```typescript
let stack = [];
stack.push(100) // 入栈
stack.push(200)
stack.push(300)
const num = stack.pop() // 出栈
stack.length  // 长度
```
 <br />**二、经典题目：判断字符串括号是否匹配的 (match-bracket.ts)**

1. 画图/思路分析
> 1、遍历字符串，遇到左括号就入栈，遇到右括号，就判断栈顶是否匹配，匹配就出栈，继续往后比对，直到最后，如果数组长度为0，证明括号正确匹配，否则就不匹配。若果中途栈顶和有括号不匹配，则括号不匹配。

2. 代码实现
```typescript
// 判断左右括号是否匹配
const isMatch = (left: string, right:string): boolean => {
  if (left === '{' && right === '}') return true
  if (left === '[' && right === ']') return true
  if (left === '(' && right === ')') return true
  return false;
}
// 判断括号是否匹配
export const matchBracket = (str: string): boolean => {
  const length = str.length;
  if(length === 0) return true;
  const stack = [];
  const leftSymbols = '{[('
  const rightSymbols = '}])'
  for(let i=0; i<length; i++) {
    const s = str[i]
    if(leftSymbols.includes(s)) {
      // 左括号，压栈
      stack.push(s)
    } else if(rightSymbols.includes(s)) {
      // 有括号，判断栈顶是否出栈
      const top = stack[stack.length - 1];
      if(isMatch(top, s)) {
        stack.pop()
      } else {
        // 有一个匹配不上，证明不匹配了
        return false
      }
    }
  }
  return stack.length === 0;
}
```

3. 功能测试
```typescript
// 功能测试
const str = '{a(b[c]d)e}f'
console.info(123123, matchBracket(str));  // 123123 true
```

4. 单元测试
```typescript
import { expect, describe, it} from 'vitest'
import { matchBracket } from './match-bracket'
describe('括号匹配', () => {
  it('正常情况', () => {
      const str = '{a(b[c]d)e}f'
      const res = matchBracket(str)
      expect(res).toBe(true)
  })
  it('不匹配', () => {
      const str = '{a(b[(c]d)e}f'
      const res = matchBracket(str)
      expect(res).toBe(false)
  })
  it('顺序不一致的', () => {
      const str = '{a(b[c]d}e)f'
      const res = matchBracket(str)
      expect(res).toBe(false)
  })
  it('空字符串', () => {
      const res = matchBracket('')
      expect(res).toBe(true)
  })
})
```

5. 性能分析
> 时间复杂度O(n)，因为数组只循环了一次，leftSymbols、rightSymbols两个只有三个元素，所以includes方法不影响性能。
> 空间复杂度O(n)，原因是定义了一个stack，压栈数量及也是数组长度

####  队列（queue）

**一、队列的基础知识**

1. 先进先出
2. API：add、delete、length
3. 队列 vs 数组
    
> 类似栈和队列。
> 队列是逻辑结构，抽象模型，可用数组和链表实现。数组是物理结构，受限于编程语言。

1. 复杂的队列服务需要单独设计
2. 用2个栈实现一个队列。
> 思路：
> 入队：往stack1中追加
> 出队：先将stack1的数据转移到stack2，然后stack2 pop，最后将stack中的数据移动到stack1中

1. 代码展示
```typescript
// 描述: 两个栈 实现一个 队列
export class MyQueue {
  private stack1: number[] = [];
  private stack2: number[] = [];
  // 描述 入列
  add(n: number) {
    this.stack1.push(n)
  }
  // 描述 出列
  delete() {
    let res,
      stack1 = this.stack1,
      stack2 = this.stack2;
    while (stack1.length) {
      const n = stack1.pop()
      if (n != null) {
        stack2.push(n);
      }
    }
    res = stack2.pop()
    while (stack2.length) {
      const n = stack2.pop()
      if (n != null) {
        stack1.push(n);
      }
    }
    return res
  }
  get length() {
    return this.stack1.length
  }
}
// 功能测试
const q = new MyQueue();
q.add(100)
console.log(q.length) // 1
q.add(200)
console.log(q.length) // 2
q.add(300)
console.log(q.length) // 3
console.log(q.delete())  // 100
console.log(q.delete()) // 200
console.log(q.delete()) // 300
```

#### 链表（linkList）

1. 链表是一种物理结构，类似于数组，每种语言都可以实现；
2. 数组是连续的内存空间，而链表是零散的
3. 链表节点的数据结构{value, next?, prev?}，单向列表无prev，最后一个节点没有next，双向第一个节点没有prev
4. 链表vs数组
> 1. 都是有序结构
> 2. 链表查询慢O(n)，新增和删除快O(1)
> 3. 数组查询快O(1)，新增和删除慢O(n)

5. 实现反转单向列表
```typescript
export interface ILinkList {
  value: number,
  next?: ILinkList
}
// 生成单向链表
export const createLinkList = (arr: number[]): ILinkList => {
  let curNode = {
    value: arr[arr.length - 1]
  }
  if (length === 1) return curNode
  for(let i=arr.length - 2; i>=0; i--) {
    curNode = {
      value: arr[i],
      next: curNode
    }
  }
  return curNode
}
// 反转单向列表
export const reserverLinkList = (list: ILinkList): ILinkList => {
  let prevNode: ILinkList | undefined = undefined;
  let curNode: ILinkList | undefined = undefined;
  let nextNode: ILinkList | undefined = list;
  while(nextNode) {
    // 第一个节点，删除next
    if(curNode && !prevNode) {
      delete curNode.next
    }
    // 中间节点 反转指针
    if(curNode && prevNode) {
      curNode.next = prevNode
    }
    // 整体指针往后移
    prevNode = curNode;
    curNode = nextNode;
    nextNode = nextNode.next;
  }
  // 单独处理最后一个节点
  if(curNode && !nextNode) {
    curNode.next = prevNode
  }
  return curNode!
}
const arr = [100,200,300,400,500];
const list = createLinkList(arr)
console.log('list---> ', list)
const list1 = reserverLinkList(list)
console.log('list1---> ', list1)
```

6. 使用链表实现队列（性能比数组高）
> - 实现逻辑：
> 1. 单向链表实现队列，同时记录head和tail
> 2. 从tail入队，从head出队
> 3. 同时记录length，避免遍历查询，消耗性能O(n) 

```typescript
export interface ILinkListNode {
  value: number;
  next: ILinkListNode | null;
}
 // 1. 单向链表实现队列，同时记录head和tail
 // 2. 从tail入队，从head出队
 // 3. 同时记录length
class MyQueue {
  private tail: ILinkListNode | null = null
  private head: ILinkListNode | null = null
  private len = 0
  add(n: number) {
    const newNode = {
      value: n,
      next: null
    }
    // 处理 head
    if(this.head == null) {
      this.head = newNode
    }
    // 处理 tail
    if(this.tail) {
      this.tail.next = newNode
    }
    this.tail = newNode
    // 处理length
    this.len++
  }
  delete(): number|null {
    if(this.head == null) return null;
    if(this.len === 0) return null;
    // 取值
    const value = this.head.value;
    // 处理 head
    this.head = this.head.next;
    // 处理length
    this.len--;
    // 处理返回值
    return value
  }
  get length () {
    return this.len
  }
}
const q = new MyQueue()
q.add(100)
q.add(200)
q.add(300)
q.add(400)
console.log('len0', q.length)
console.log('delete1', q.delete())
console.log('len1', q.length)
console.log('delete2', q.delete())
console.log('len2', q.length)
console.log('delete3', q.delete())
console.log('len3', q.length)
console.log('delete4', q.delete())
console.log('len4', q.length)
console.log('delete5', q.delete())
console.log('len5', q.length)
```

> demo代码地址: [https://gitee.com/dengxiangguang/algorithm.git](https://gitee.com/dengxiangguang/algorithm.git)


### 常见算法题
#### 1.  js实现二分查找（binary-search）
```typescript
// 二分法查找
// 循环方式实现 性能更佳
export const binarySearch1 = (arr: number[], target: number): number => {
  if(!arr?.length) return -1;
  let startIndex: number = 0;
  let endIndex: number = arr.length - 1;
  let midValue: number|undefined = undefined;
  while(startIndex <= endIndex) {
    const midIndex: number = Math.floor((startIndex + endIndex) / 2);
    midValue = arr[midIndex];
    if(midValue > target) {
      // 目标在左侧
      endIndex = midIndex - 1;
    } else if(midValue < target) {
      // 目标在右侧
      startIndex = midIndex + 1
    } else {
      return midIndex
    }
  }
  return -1
}
// 递归方式实现
export const binarySearch2 = (arr: number[], target: number, startIndex?:number, endIndex?: number): number => {
  if(!arr?.length) return -1;
  if(!startIndex) startIndex = 0;
  if(!endIndex) endIndex = arr.length - 1;
  const midIndex = Math.floor((startIndex + endIndex) / 2);
  const midValue = arr[midIndex];
  if(startIndex > endIndex) return -1;
  if(midValue > target) {
    return binarySearch2(arr, target, startIndex, midIndex - 1)
  } else if(midValue < target) {
    return binarySearch2(arr, target, midIndex + 1, endIndex)
  } else {
    return midIndex
  }
}
// 功能测试
const arr = [1,2,3,4,5,6]
const target = 6
console.log(binarySearch1(arr, target))
console.log(binarySearch2(arr, target))
```

#### 2. 给一个递增数组，找出和为n的两个数，例如： [1,2,3,4,6,7,9,11,15]，找出和为15的两个数

- 划重点
> - 实现方式：1. 循环（O(n^2)）  2.双指针(O(n))
> - 反有序，必二分；优化循环可以考虑‘双指针’

- 循环
- 双指针：利用递增（有序）特性，如果和大于n，往前寻找，否则往后寻找。
```typescript
// 循环方式，复杂度O(n^2)
export const findSum = (arr: number[], target: number): number[] => {
  const res: number[] = [];
  const length = arr.length;
  if(!length) return [];
  let flag: boolean = false;
  for(let i = 0; i <= length - 1; i++) {
    const n1 = arr[i];
    for(let j = i+1; j<=length-1; j++) {
      const n2 = arr[j];
      if(n1 + n2 == target) {
        res.push(n1);
        res.push(n2);
        flag = true;
        break;
      }
    }
    if(flag) break;
  }
  return res;
}
// 双指针 复杂度O（n）
export const findSum2 = (arr: number[], target: number): number[] => {
  let res: number[] = [];
  const length = arr.length;
  if(!length) return res;
  let startIndex: number = 0;
  let endIndex: number = length-1;
  while(startIndex <= endIndex) {
    const n1 = arr[startIndex];
    const n2 = arr[endIndex];
    const sum =  n1 + n2;
    if(sum == target) {
      res.push(n1)
      res.push(n2)
      break;
    } else if (sum > target) {
      endIndex--
    } else if (sum < target) {
      startIndex++
    }
  }
  return res;
}
// 功能测试
console.log('findSum', findSum([1,2,3,4,6,7,9,11,15], 15))
console.log('findSum2', findSum2([1,2,3,4,6,7,9,11,15], 15))
```
