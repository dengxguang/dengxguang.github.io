1. ssr/csr 项目中 webpack 配置有哪些关键差异
2. vue计算属性的原理，react怎样实现同样的功能
3. fiber 是什么，为什么vue不需要fiber呢
- fiber
> fiber 是 React16 提出的一种更新机制，将同步不可中断的更新变成异步可中断更新。将原本一个耗时的大任务做了时间分片，拆成多个小任务，在浏览器空闲时间执行，此外添加优先级概念，先执行优先级高的任务，如用户交互的响应等等。
> fiber 架构中，每个节点有三个指针，分别指向父节点、子节点和下一个兄弟节点，而旧架构的节点只有一个指向子节点的指针，所以中断恢复后会丢失父节点

- react需要fiber的原因
> 因为react组件调用setState方法更新状态后，react组件会自顶向下重新渲染组件。自顶向下含义是父组件以及父组件的所有子组件都会重新渲染。而且浏览器中渲染和运行js代码是占用同一个线程，这样由于渲染造成页面阻塞不能及时响应用户交互。

- vue 不用 fiber 的原因
> vue 使用 Object.defineProperty(vue@3使用proxy)对数据的setter和getter做了劫持，也就是说vue可以精确知道视图模块哪一块用到了该数据，并且在这个数据修改时告诉视图需要从新更新。

因此，当一个数据变化时，react组件渲染是很消耗性能的---父组件更新了所有子组件也要更新，而vue组件可以精确到当前组件的粒度进行更新。

- 从底层看响应原理
> vue：直接修改原来的那块原始内存
> react：调用`setState`方法。组件状态时不能被修改的，setState没有修改原来那块内存中的变量，而是去从新开辟一个新的内存空间，也就是常说的‘immutable’不可变的。

- react VS vue
> react fiber 是用来弥补更新时的‘无脑’更新，不够精确带来的缺陷。这也不说明react性能更差。其实vue实现精确更新也是有代价的，一方面是需要给每个组件添加一个‘监听器’（watcher），用于视图依赖收集和数据更新时发布通知，这性能同样有消耗的；另一方面vue能实现依赖收集得益于模板语法实现静态编译，这个是react使用JSX语法做不到的。

参考：[阿里三面：有React fiber，为什么不需要Vue fiber呢？-阿里为什么不用zookeeper](https://www.51cto.com/article/704554.html)

4. sentry 怎么去捕获错误的呢

> 为了能自动捕获应用异常，Sentry 劫持覆写了 window.onerror 和 window.unhandledrejection 这两个 api。

1. bff 架构 监控和警告
2. 监控系统的架构设计
- 前端需要分析的数据

> 1. PV/UV
> 2. 接口请求统计
> 3. 耗时统计
> 4. 异常错误统计

**监控流程： 监听并收集错误 -> 存储并上报错误 -> 分析并聚合错误 -> 发送错误报警 -> 定位并解决错误**<br /> 

**前端常见异常有：**

- js代码执行时异常
- promise类型异常
- 资源加载类型异常
- 网络请求类型异常
- 跨域脚本执行异常

**前端常见异常捕获方式**：

- js代码异常： window.error，但是不能捕页面初始化时的错误，需要重写console.error方法来捕获
5. 用户使用设备统计
6. 用户地域分布统计
7. 页面用户行为统计

...


- 参考
> [前端错误监控-Sentry自动捕获前端应用异常原理 - 51Testing软件测试网](http://www.51testing.com/html/23/n-7794223.html)
> [搭建前端监控系统（一）阿里云服务器搭建篇 - 一步一个脚印一个坑 - 博客园](https://www.cnblogs.com/warm-stranger/p/8837784.html)

1. 移动端适配方案
2. vue 响应式原理
> - 当一个Vue组件实例创建时，vue会遍历data选项的属性，使用`Object.defineProperty`将他们转为getter/setter，并且在内部关联追踪相关依赖，当属性被访问和修改时通知变化。
> - 每个组件实例都有响应的`watcher`程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时会通知`watcher`重新计算，从而使它关联的组件得以更新。

