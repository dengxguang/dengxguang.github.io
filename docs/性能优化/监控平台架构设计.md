# 前端性能与异常监控全链路设计

> 重难点
> 1. 全栈项目架构
> 2. Kafka + clickhouse + Flink 实时数据流经典架构设计
> 3. 性能与异常指标采集
> 

### 性能指标

#### 核心点

1. 打开速度怎么变快 -- 首屏加载优化
2. 再次打开速度怎么变快 -- 缓存优化
3. 操作怎么顺畅 -- 渲染优化
4. 动画怎么保持流畅 -- 长任务拆分

回答角度：先说明问题，怎么衡量加载情况（哪些性能指标），提升了多少。

#### 首屏加载指标细化
- FP (First Paint) 首次绘制
- FCP (First Contentful Paint) 首次内容绘制, FP 到 FCP 中间其实主要是SPA应用js执行，太慢就会出现白屏
- FMP (First Meaningful Paint) 首次有意义绘制，FCP 到 FMP 之间主要是骨架屏渲染，骨架屏渲染的快慢决定了用户体验的好坏
- LCP (Largest Contentful Paint) 最大内容绘制，加载大内容块呈现时间

#### 交互指标细化
- INP (Interaction to Next Paint) 交互到下一次绘制时间
- TTI (Time to Interactive) 可交互时间
- TBT (Total Blocking Time) 总阻塞时间
- TTFB (Time to First Byte) 首次字节到达时间
- CLS (Cumulative Layout Shift) 累计布局偏移，重排、 reflow
- FID (First Input Delay) 首次输入延迟

#### 性能优化方案

- 打包构建，工程化层面
  - 代码拆分、压缩
  - 摇树优化
  - 懒加载
  - 虚拟列表
  - ...

- 网络
  - http2
  - cdn
  - prefetch、preload

### 前端性能与异常监控指标怎么计算

#### 借助 Perfomance API && MoturationObserver API

```js
// FCP 计算
if (performance.timing.navigationStart) {
  const fcp = performance.timing.navigationStart + performance.timing.responseStart
}

```

#### 性能指标数据上报

```js
import {getCLS, getFID, getLCP} from 'web-vitals';

getCLS(reportPerformance);
getFID(reportPerformance);
getLCP(reportPerformance);

function reportPerformance({name, value}) {
  report({
    type: 'PERFORMANCE',
    metric: name,
    value: Math.round(value),
    rating: 
      value < 100 ? 'good' : 
      value < 250 ? 'needs-improvement' : 'poor'
  });
}

```


### 异常监控

#### 前端有哪些常见的异常？

- 内存溢出
- 白屏 -- MutationObserver 监听 DOM 变化
- 资源加载失败
  - 图片加载失败（静态资源）
  - font 资源 （静态资源）
  - ...
- js 运行错误
  - 异常如何监听？
- 异步处理异常
  - promise - 可以监听 unhandlerejection 事件
- 网络异常
  - ajax
  - fetch
  
#### 具体监控方法

```js
// JS错误监听
window.addEventListener('error', (event) => {
  const { message, filename, lineno, colno, error } = event;
  report({
    type: 'JS_ERROR',
    message,
    file: filename,
    line: lineno,
    column: colno,
    stack: error?.stack,
    ua: navigator.userAgent
  });
});

// Promise异常
window.addEventListener('unhandledrejection', (event) => {
  report({
    type: 'PROMISE_REJECTION',
    reason: event.reason?.message || String(event.reason),
    stack: event.reason?.stack
  });
});

// 资源加载错误
document.addEventListener('error', (event) => {
  const target = event.target;
  if (target instanceof HTMLElement) {
    report({
      type: 'RESOURCE_ERROR',
      tagName: target.tagName,
      src: target.src || target.href,
      outerHTML: target.outerHTML.slice(0, 300) // 截取部分HTML
    });
  }
}, true);

// 接口监控（XHR拦截示例）
const originalXHROpen = XMLHttpRequest.prototype.open;
XMLHttpRequest.prototype.open = function(method, url) {
  this._requestData = { method, url, start: Date.now() };
  
  this.addEventListener('loadend', () => {
    const duration = Date.now() - this._requestData.start;
    if (this.status >= 400) {
      report({
        type: 'API_ERROR',
        status: this.status,
        method,
        url,
        duration,
        response: this.responseText?.slice(0, 1000) // 安全截断
      });
    }
  });
  
  originalXHROpen.apply(this, arguments);
};

```


### 用户行为埋点

- 埋点类型
  - 手动埋点，侵入性比较强
  - 无痕埋点，对于服务端压力比较大，所有的操作都会上报，（时间冒泡，eventPath来处理）
  - 可视化埋点

- 常规指标
  - PV、UV
  - 跳出率
  - 会话时长
  - 取决于数据、运营团队的指标

### 上报方式

- img.gif：动态创建img标签，src指向日志服务器，（优点：可以跨域， 缺点：携带的数据比较少）
- fetch
- navigation.sendBeacon

### 整体流程设计

- 基础服务：nodejs、java、nginx、go、Python，微服务架构（microservice）
- 数据库：mysql、mongoDB
- 消息队列：kafka(topic)✅、rabbitmq、rocketmq
- 实时数据加工：Flink✅、spark、storm
- 数据落库：clickhouse✅、hbase、Hadooop、CDH、starRock
- 查询：clickhouse
- 可视化：json、echarts、d3、highcharts

### 项目实战，监控平台方案设计与落地

- 基础服务：nest.js

